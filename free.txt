#1.Write a program to implement logical 
#gates AND, OR and NOT with 
McCulloch-Pitts
class McCullochPittsNeuron:
    def __init__(self, weights, threshold):
        self.weights = weights
        self.threshold = threshold
    def activation(self, inputs):
        # Calculate the weighted sum
        weighted_sum = sum(w * inp for w, inp in zip(self.weights, inputs))
        # Apply the threshold function
        return 1 if weighted_sum >= self.threshold else 0
# AND gate
def AND_gate(x1, x2):
    weights = [1, 1]
    threshold = 2
    neuron = McCullochPittsNeuron(weights, threshold)
    return neuron.activation([x1, x2])
# OR gate
def OR_gate(x1, x2):
    weights = [1, 1]
    threshold = 1
    neuron = McCullochPittsNeuron(weights, threshold)
    return neuron.activation([x1, x2])
# NOT gate
def NOT_gate(x):
    weights = [-1]
    threshold = 0
    neuron = McCullochPittsNeuron(weights, threshold)
    return neuron.activation([x])
# Testing the gates
print("AND Gate:")
print(f"AND(0, 0) = {AND_gate(0, 0)}")
print(f"AND(0, 1) = {AND_gate(0, 1)}")
print(f"AND(1, 0) = {AND_gate(1, 0)}")
print(f"AND(1, 1) = {AND_gate(1, 1)}")
print("\nOR Gate:")
print(f"OR(0, 0) = {OR_gate(0, 0)}")
print(f"OR(0, 1) = {OR_gate(0, 1)}")
print(f"OR(1, 0) = {OR_gate(1, 0)}")
print(f"OR(1, 1) = {OR_gate(1, 1)}")
print("\nNOT Gate:")
print(f"NOT(0) = {NOT_gate(0)}")
print(f"NOT(1) = {NOT_gate(1)}")

2.Write a program to implement Hebb’s rul
import numpy as np
class HebbianLearning:
    def __init__(self, input_size):
        self.weights = np.zeros(input_size)
    def train(self, inputs, outputs):
        for input_vector, output in zip(inputs, outputs):
            self.weights += input_vector * output
    def predict(self, input_vector):
        return np.dot(input_vector, self.weights)
# Training data for a simple AND gate
inputs = np.array([
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1]
])
outputs = np.array([0, 0, 0, 1])
hebbian = HebbianLearning(input_size=2)
hebbian.train(inputs, outputs)
print("Trained Weights:", hebbian.weights)
# Testing the model
print("Predictions:")
for input_vector in inputs:
    prediction = hebbian.predict(input_vector)
    print(f"Input: {input_vector}, Predicted Output: {prediction}")

3.Implement Kohonen Self organizing map.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

dataset=pd.read_csv('')
dataset
X = dataset.iloc[:,:-1].values    
y = dataset.iloc[:,-1].values
from sklearn.preprocessing import MinMaxScalar
sc=MinMaxScalar(feature_range=(0,1))
X =sc.fit_transform(X)
X
from minisom import MiniSom
som=MiniSom(x= 10,y=10,input_len=15,sigma=1.0, learning_rate=0.5)
from pylab import bone,pcolor,colorbar,plot,show
bone()
pcolor(som.distance_map().T)
colorbar()
mappings=som.win_map(x)
mappings
fraunds=np.concatenate((mappings[(1,1)],mappings[(4,1)]),axis=0)
frauds
frauds=sc.inverse_transform(frauds)
frauds

4.Implement a program to find the winning neuron using MaxNet
import numpy as np
def maxnet(input_vector, learning_rate, epochs):
 num_neurons = len(input_vector)
 weights = np.ones(num_neurons)
 for _ in range(epochs):
   for i in range(num_neurons):
    net_input = np.dot(weights, input_vector)
    weights[i] += learning_rate * (input_vector[i] - net_input)
 # Normalize weights
 weights = weights / np.linalg.norm(weights)
 # Find the winning neuron (index of the neuron with maximum weight)
 winning_neuron = np.argmax(weights)
 return winning_neuron
# Example usage
input_vector = np.array([0.2, 0.4, 0.6, 0.8])
learning_rate = 0.1
epochs = 100
winner = maxnet(input_vector, learning_rate, epochs)
print("Winning neuron index:", winner)

5.Implement De-Morgan‟s Law
import numpy as np
# Function to implement De Morgan's Law for conjunction in fuzzy logic
def demorgans_law_conj(p, q):
 result = np.minimum(1, 1 - (p + q))
 return result
# Function to implement De Morgan's Law for disjunction in fuzzy logic
def demorgans_law_disj(p, q):
 result = np.maximum(0, 1 - (p + q))
 return result
# Test De Morgan's laws
p = 0.7
q = 0.4
print("De Morgan's Law for Conjunction: ", demorgans_law_conj(p, q))
print("De Morgan's Law for Disjunction: ", demorgans_law_disj(p, q))

6.Implement Union, Intersection, Complement and Difference operations on fuzzy sets.
def fuzzy_union(set1, set2):
  union_set = {}
  for element in set1.keys() | set2.keys():
     union_set[element] = max(set1.get(element, 0), set2.get(element, 0))
  return union_set
def fuzzy_intersection(set1, set2):
   intersection_set = {}
   for element in set1.keys() & set2.keys():
     intersection_set[element] = min(set1[element], set2[element])
   return intersection_set
def fuzzy_complement(set1):
   complement_set = {}
   for element, membership in set1.items():
     complement_set[element] = 1 - membership
   return complement_set
def fuzzy_difference(set1, set2):
   difference_set = {}
   for element, membership in set1.items():
    if element not in set2:
      difference_set[element] = membership
   return difference_set
# Example fuzzy sets
set1 = {'a': 0.7, 'b': 0.5, 'c': 0.3}
set2 = {'b': 0.6, 'c': 0.4, 'd': 0.2}
# Perform operations
union_set = fuzzy_union(set1, set2)
intersection_set = fuzzy_intersection(set1, set2)
complement_set1 = fuzzy_complement(set1)
complement_set2 = fuzzy_complement(set2)
difference_set = fuzzy_difference(set1, set2)
# Display results
print("Union Set:", union_set)
print("Intersection Set:", intersection_set)
print("Complement of Set 1:", complement_set1)
print("Complement of Set 2:", complement_set2)
print("Difference Set (Set1 - Set2):", difference_set)

7.Create fuzzy relation by Cartesian product of any two fuzzy set
def cartesian_product(set1, set2):
 fuzzy_relation = {}
 for element1, membership1 in set1.items():
  for element2, membership2 in set2.items():
   fuzzy_relation[(element1, element2)] = min(membership1, membership2)
 return fuzzy_relation
# Example fuzzy sets
set1 = {'a': 0.7, 'b': 0.5, 'c': 0.3}
set2 = {'x': 0.6, 'y': 0.4, 'z': 0.2}
# Create fuzzy relation
fuzzy_relation = cartesian_product(set1, set2)
# Display fuzzy relation
print("Fuzzy Relation:")
for pair, membership in fuzzy_relation.items():
 print(pair, ":", membership)

8.Perform max-min composition on any two fuzzy relations
import numpy as np

def max_min_composition(R1, R2):
   
    # Validate the input matrices
    if R1.shape[1] != R2.shape[0]:
        raise ValueError("The number of columns in R1 must match the number of rows in R2.")

    # Initialize the result matrix
    result = np.zeros((R1.shape[0], R2.shape[1]))

    # Perform max-min composition
    for i in range(R1.shape[0]):
        for j in range(R2.shape[1]):
            min_values = [min(R1[i, k], R2[k, j]) for k in range(R1.shape[1])]
            result[i, j] = max(min_values)
    return result
# Example fuzzy relations
R1 = np.array([
    [0.2, 0.5, 0.3],
    [0.8, 0.4, 0.6]
])
R2 = np.array([
    [0.9, 0.1],
    [0.7, 0.8],
    [0.6, 0.3]
])
# Perform max-min composition
result = max_min_composition(R1, R2)

print("Result of max-min composition:")
print(result)



